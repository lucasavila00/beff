# ðŸª„ Beff

Efficient validators from TypeScript types generated by a blazing fast compiler.

- **TypeScript Efficient**: Unlike zod, io-ts and similar libraries, Beff doesn't generate any extra work for the TypeScript compiler. Enjoy fast editor performance and quick compile times.
- **Fast**: Beff is written in Rust and compiled to WebAssembly. It's supported on every OS and should work seamlessly for you!
- **Really Fast**: Beff compiles a hello-world project in 5ms. A large project with 200+ types compiles in just 200ms.
- **Compatible**: Beff uses the TypeScript compiler for path resolution. If your editor can find the types, so can Beff.
- **Efficient Generated Code**: Beff generates optimal validator code, applying many optimizations at compile time.
- **Helpful**: Beff generates clear error messages both at compile time and at validation time.
- **Powerful**: Beff supports recursive types, generic types, mapped types, conditional types, `Omit`, `Exclude`, `Partial`, `Required`, `Record`, and much more. If it makes sense to have a runtime validator for a type, Beff will understand it.

## Getting Started

### 1. Install

Install `@beff/cli` and `@beff/client` from npm.

```shell
npm i @beff/cli @beff/client
```

### 2. Configure

Create a JSON file to configure Beff. The file can have any name, but it's standard practice to name it `beff.json`.

```json
{
  "parser": "./src/parser.ts",
  "outputDir": "./src/generated"
}
```

### 3. Create the parser file

Create a TypeScript file that lists the types for which Beff should generate validators.

It's standard practice to call it `parser.ts`.

```ts
import parse from "./generated/parser";

type User = {
  name: string;
  age: number;
};

export const Parsers = parse.buildParsers<{
  User: User;
}>();
```

### 4. Generate the parser code

`@beff/cli` installs a `beff` binary.

```shell
npx beff -p beff.json
```

### 5. Use the validators

```ts
import { Parsers } from "./parser.ts";

const user1 = Parsers.User.parse({
  name: "John Doe",
  age: 42,
});

const maybeUser = Parser.User.safeParse(null);

const isValid: boolean = Parser.User.validate({
  name: "John Doe",
  age: 42,
});

const jsonSchema = Parser.User.schema();
```

## CLI Options

The `beff` binary can also run in watch mode.

```shell
$ npx beff -h
Usage: beff [options]

Generate validators from typescript types

Options:
  -p, --project <string>  Path to the project file
  -v, --verbose           Print verbose output
  -w, --watch             Watch for file changes
  -h, --help              display help for command
```

## Features

### Custom String Formats

Configure your `beff.json`

```json
{
  "parser": "./src/parser.ts",
  "outputDir": "./src/generated",
  "stringFormats": [
    {
      "name": "ValidCurrency"
    }
  ]
}
```

Use the helper `StringFormat` to create the type. It creates a branded TypeScript type.
Define the runtime validator in the build parsers call.

```ts
import parse from "./generated/parser";
import { StringFormat } from "@beff/client";
export type ValidCurrency = StringFormat<"ValidCurrency">;

export const Parsers = parse.buildParsers<{
  ValidCurrency: ValidCurrency;
}>({
  stringFormats: {
    ValidCurrency: (input: string) => {
      if (VALID_CURRENCIES.include(input)) {
        return true;
      }
      return false;
    },
  },
});
```

### Custom Number Formats

Configure your `beff.json`

```json
{
  "parser": "./src/parser.ts",
  "outputDir": "./src/generated",
  "numberFormats": [
    {
      "name": "ValidCurrency"
    }
  ]
}
```

Use the helper `NumberFormat` to create the type. It creates a branded TypeScript type.
Define the runtime validator in the build parsers call.

```ts
import parse from "./generated/parser";
import { NumberFormat } from "@beff/client";
export type NonNegativeNumber = NumberFormat<"NonNegativeNumber">;

export const Parsers = parse.buildParsers<{
  NonNegativeNumber: NonNegativeNumber;
}>({
  numberFormats: {
    NonNegativeNumber: (input: number) => {
      return input >= 0;
    },
  },
});
```

### Ad-hoc, one-off validator generator

Beff supports a type creation API similar to `zod`, `io-ts`, and similar libraries.

However, Beff's type creation API is very limited and only supports a few types.

With Beff, complex types should be generated by compiling TypeScript types.

Types generated with the ad-hoc API have the same properties and methods as regular compiled types.

```ts
import { b } from "@beff/client";

const AdHocItem = b.Object({
  str: b.String(),
  num: b.Number(),
  bool: b.Boolean(),
  undefined: b.Undefined(),
  null: b.Null(),
  any: b.Any(),
  unknown: b.Unknown(),
});

const AdHocList = b.Array(AdHocItem);

const ls = AdHocList.parse([]);
```

### Zod Compatibility

Call `.zod()` on a parser to create a `zod` type.

This is useful for gradually migrating from `zod`.

```ts
import { Parsers } from "./parser.ts";
import { z } from "zod";

const users = z.array(Parsers.User.zod()).parse({
  name: "John Doe",
  age: 42,
});
```

## Contributing

Please read [CONTRIBUTING.md](/CONTRIBUTING.md)
